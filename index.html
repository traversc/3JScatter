<html>
<head>
<title>3JScatter: 3D scatter plotter</title>
	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/d3.v3.min.js"></script>
	<script src="js/helvetiker_regular.typeface.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/jquery-1.11.2.min.js"></script>
	<script src="js/customDataAndFunctions.js"></script>
	<link type="text/css" href="css/styles.css" rel="stylesheet"/>
	<!--script src="js/SVGRenderer.js"></script-->

</head>
	<body>
		<div id="title">3JScatter: 3D scatter plotter</div>
		<div id="plotarea"><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 1: <a href="javascript:demo1();">Tissue sub-type Principal Component Analysis</a><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 2: <a href="javascript:demo2();">Different shape example</a><br><br>
		</div>
		<div id ="footer">
		<form id="form1">
			Input Data<br><input type="button" value="Plot Data" onclick="init()"><input type="button" value="Reset" onclick="location.reload();">
			<textarea id="textinputarea" rows="5"></textarea>
			<!--input type="button" value="Plot Data" onclick="init()">
			<!--input type="button" value="Demo" onclick="init()">
			<!--textarea id="svgoutput" rows="5"></textarea-->
			<!--input type="button" value="Go" onclick="init()" /-->
			<!--input type="button" value="Enable Shadows" onclick="enableshadows()" /-->
			<!--input type="button" value="Enable histogram lines" onclick="enablehistXY()" /-->
			<!--input type="button" value="Stop" onclick="uninit()" /-->
			<!--input type="button" value="Export" onclick="exportpng()" /-->
		</form>
		</div>
		<script>
			var camera, controls, scene, renderer;
			var points = [];
			var histLines = [];
			//var cube_outlines = [];
			var texts = [];
			var controls_enabled = false;
			function demo1() {
				cam_init_pos = [100,55,70];
				$('#textinputarea').get(0).value = demostring01;
				$("#plotarea").empty();
				init();
			}
			function demo2() {
				cam_init_pos = [20,-10,-150];
				$('#textinputarea').get(0).value = demostring02;
				$("#plotarea").empty();
				init();
			}
			
			//dat.gui variables
			function exportpng() {
				window.open(renderer.domElement.toDataURL('image/png'),'screenshot');
			}	
			function freeze() {
				controls_enabled = !controls_enabled;
				if(controls_enabled && typeof renderer != 'undefined') {
					animate();
				}
			}
			function clearSettings() {
				localStorage.clear();
				location.reload();
			}
			var light_enabled = true;
			var shadows_enabled = false;
			var fix_plot_dimensions = false;
			var fix_axes_loc = false;
			var axes_origin_x = 0;
			var axes_origin_y = 0;
			var axes_origin_z = 0;
			var gui = new dat.GUI({width:300});
			gui.remember(this);
			localStorage.setItem(document.location.href + '.isLocal','true'); //default save to local storage automatically
			var light_control = gui.add(this, 'light_enabled').name('Add Light');
			var shadow_control = gui.add(this, 'shadows_enabled').name('Enable Shadows');
			
			//axes location
			var axes_origin_folder = gui.addFolder('Fix Axes Origin');
			var fix_axes_control = axes_origin_folder.add(this, 'fix_axes_loc').name('Set Origin of Axes');
			axes_origin_folder.add(this, 'axes_origin_x').name('X');
			axes_origin_folder.add(this, 'axes_origin_y').name('Y');
			axes_origin_folder.add(this, 'axes_origin_z').name('Z');
			axes_origin_folder.open();
			
			//plot size controls //plotsize_folder.open();
			var plotsize_folder = gui.addFolder('Fix Plot Dimensions');
			var fix_size_control = plotsize_folder.add(this, 'fix_plot_dimensions').name('Fix Plot Size');
			plotsize_folder.add(this, 'fix_height', 480,1440).name('Plot Height');
			plotsize_folder.add(this, 'fix_width', 640,2560).name('Plot Width');
			plotsize_folder.open();

			function reset() { //reload webpage, is there a better way?
				location.reload();
			}
			//gui.add(this, 'freeze').name('Freeze/Unfreeze');
			gui.add(this, 'exportpng').name('Export as PNG');
			gui.add(this, 'reset').name('Reset Plot');
			gui.add(this, 'clearSettings').name('Clear Settings');
			gui.close();			
			function init() {
				renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer: true, alpha: true});
				//renderer = new THREE.WebGLRenderer();
				//renderer = new THREE.SVGRenderer({antialias:true});
				var w,h;
				if(fix_plot_dimensions) {
					w = fix_width;
					h = fix_height;
				} else {
					w = document.getElementById('plotarea').clientWidth;
					h = document.getElementById('plotarea').clientHeight;
				}
				renderer.setSize(w, h);
				renderer.setClearColor(bgcolor, 1.0);
				if(shadows_enabled) {
					console.log("shadows");
					renderer.shadowMapEnabled = true;
				}
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
				renderer.domElement.id = "myrenderer";
				var plotarea = document.getElementById('plotarea');
				plotarea.appendChild(renderer.domElement);
				//controls.addEventListener( 'change', render );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, w / h, 1, 1000);
				renderer.render(scene,camera);
				var text = document.getElementById('textinputarea').value; 
				var unfiltered = d3.csv.parseRows(text);			
				var labels = unfiltered[0];
				unfiltered.shift(); //remove first element (header)		
				var x_ind = labels.indexOf("x");
				var y_ind = labels.indexOf("y");
				var z_ind = labels.indexOf("z");
				var size_ind = labels.indexOf("size");
				var hist_ind = labels.indexOf("hist");
				var pch_ind = labels.indexOf("pch");
				var color_ind = labels.indexOf("color");
				var histcolor_ind = labels.indexOf("histColor");
				var outlineColor_ind = labels.indexOf("outlineColor");
				
				var xcoords = normalize(unfiltered, x_ind, xscale);
				var ycoords = normalize(unfiltered, y_ind, yscale);
				var zcoords = normalize(unfiltered, z_ind, zscale);
				
				for (var i = 0; i < unfiltered.length; i ++) {
					var size = ifelser(size_ind == -1,default_size,unfiltered[i][size_ind]);
					var pch = ifelser(size_ind == -1,default_pch,unfiltered[i][pch_ind]);
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var color = ifelser(color_ind == -1,default_color,unfiltered[i][color_ind]);
					var outlineColor = ifelser(outlineColor_ind == -1,default_outlineColor,unfiltered[i][outlineColor_ind]);
					var point = pointMesh(pch, size, color, outlineColor);
					point.position.x = x;
					point.position.y = y;
					point.position.z = z;
					point.castShadow = true;
					scene.add(point);
				}
				
				//could make hist line a tube instead, for more customizability
				for (var i = 0; i < unfiltered.length; i ++) {
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var hist = ifelser(hist_ind == -1,default_hist,unfiltered[i][hist_ind]);
					var histcolor = ifelser(histcolor_ind == -1,default_histcolor,unfiltered[i][histcolor_ind]);
					if(hist == 1) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, 0), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: histcolor,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
					if(hist == 2) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, -zscale * 1.25), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: histcolor,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
				}

				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(
					v(xscale * 1.25, 0, 0), v(-xscale * 1.25, 0, 0),
					v(0, yscale * 1.25, 0), v(0, -yscale * 1.25, 0),
					v(0, 0, zscale * 1.25), v(0, 0, -zscale * 1.25)
				);
				var lineMat = new THREE.LineBasicMaterial({
					color: 0x000000,
					lineWidth: 1
				});
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				
				//arrows
				var triangle = new THREE.Shape();
				triangle.moveTo(0,0);
				triangle.lineTo(0.5, -1);
				triangle.lineTo(-0.5, -1);
				triangle.lineTo(0,0);
				var geometry = triangle.makeGeometry();
				var material = new THREE.MeshBasicMaterial({ color: 0x000000 });
				material.side = THREE.DoubleSide;
				zarrow = new THREE.Mesh(geometry, material);
				zarrow.position.z = zscale * 1.25;
				zarrow.rotation.x = Math.PI/2;
				scene.add( zarrow );
				xarrow = new THREE.Mesh(geometry, material);
				xarrow.position.x = xscale * 1.25;
				xarrow.rotation.z = -Math.PI/2;
				scene.add( xarrow );
				yarrow = new THREE.Mesh(geometry, material);
				yarrow.position.y = yscale * 1.25 + 1;
				scene.add( yarrow );
				
				// bottom plane for shadows / reflections
				var geometry = new THREE.PlaneGeometry(10000,10000);
				var plane_mat = new THREE.MeshBasicMaterial( {color: bgcolor} );
				var plane = new THREE.Mesh( geometry, plane_mat );
				plane.receiveShadow = true;
				plane.position.z = -zscale * 1.25;
				scene.add( plane );
				

				//text

				//text3d.computeBoundingBox();
				//var centerOffsetx = -0.5 * ( text3d.boundingBox.max.x - text3d.boundingBox.min.x );
				//var centerOffsetz = -0.5 * ( text3d.boundingBox.max.z - text3d.boundingBox.min.z );
				var textMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } );
				var text3d = new THREE.TextGeometry( "x", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				THREE.GeometryUtils.center( text3d )
				var x_lab = new THREE.Mesh( text3d, textMaterial );
				x_lab.position.x = xscale * 1.35;
				texts.push(x_lab);
				scene.add( x_lab );
				var text3d = new THREE.TextGeometry( "y", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				var y_lab = new THREE.Mesh( text3d, textMaterial );
				THREE.GeometryUtils.center( text3d )
				y_lab.position.y = yscale * 1.35;
				texts.push(y_lab);
				scene.add( y_lab );
				var text3d = new THREE.TextGeometry( "z", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				var z_lab = new THREE.Mesh( text3d, textMaterial );
				THREE.GeometryUtils.center( text3d )
				z_lab.position.z = zscale * 1.45;
				texts.push(z_lab);
				scene.add( z_lab );
					
				// lights
				if(light_enabled) {
					light = new THREE.SpotLight( 0xcccccc );
					light.position.set( 0,0, 1000);
					light.castShadow = true;
					light.shadowDarkness = 0.5;
					light.shadowCameravisible = true;
					scene.add( light );
				}
				
				camera.position.z = cam_init_pos[0];
				camera.position.x = cam_init_pos[1];
				camera.position.y = cam_init_pos[2];
				camera.up = v( 0, 0, 1 );
				controls = new THREE.OrbitControls( camera );
				controls.damping = 0.2;
				
				controls_enabled = true;
				animate();
			}
			function animate() {
				if(controls_enabled) {
					requestAnimationFrame(animate);
					//for(var k = 0; k<cube_outlines.length; k++){
					//	cube_outlines[k].lookAt( camera.position );  					 
					//}
					for(var k = 0; k<texts.length; k++){
						texts[k].quaternion.copy( camera.quaternion );					
					}
					//console.log(zaxis.rotation);
					//mesh.lookAt(camera.position);	
					zarrow.rotation.x = Math.PI/2;
					zarrow.rotation.z = 0;
					zarrow.rotation.y = -Math.atan(camera.position.x/camera.position.y);
					//console.log(mesh.rotation.y);
					//mesh.rotation.y +=0.1;
					renderer.render(scene, camera);
					controls.update();
				}
			}	
		</script>
	</body>
</html>
