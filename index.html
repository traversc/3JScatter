<!DOCTYPE html>
<html>
<head>
<title>3JScatter: 3D scatter plotter</title>
	<!--predefined libraries-->
	<link rel="stylesheet" href="css/bootstrap.css">
	<link rel="stylesheet" href="css/bootstrap-theme.css">
	<script src="js/three.min.v69.js"></script>  
	<script src="js/WebGLDetector.js"></script>  
	<script src="js/OrbitControls.js"></script>
	<script src="js/d3.v3.min.js"></script>
	<script src="js/helvetiker_regular.typeface.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/jquery-1.11.2.min.js"></script>
	<script src="js/handsontable.full.min.js"></script>
	<link rel="stylesheet" href="css/handsontable.full.min.css">

	
	
	<!--own code-->
	<script src="js/tc.functions.js"></script>
	<script src="js/tc.gui.controls.js"></script>
	<script src="js/tc.data.input.js"></script>
	<link type="text/css" href="css/styles.css" rel="stylesheet"/>

</head>
	<body>
		<!--div id="title">3JScatter: 3D scatter plotter</div-->
		<div id="plotarea">
		Demo 1: <a href="javascript:demo1();">Tissue sub-type Principal Component Analysis</a><br>
		Demo 2: <a href="javascript:demo2();">Different shape example</a><br>
		Demo 3: <a href="javascript:demo3();">Line plot example (Dow Jones Industrial Average)</a><br><br>
		<span id="notice">This page uses Javascript.  Please use the latest version of Chrome or Firefox.</span>
		</div>
		<div id="footer">
			<div id="input_container">
				Controls
				<div id="add_series_form" class="input_controls">
					ADD DATA SERIES<br>
					<button type="button" class="btn btn-block btn-default btn-sm" onclick="init()">Add Points</button>
					<button type="button" class="btn btn-block btn-default btn-sm" onclick="init()">Add Lines</button>
					<button type="button" class="btn btn-block btn-default btn-sm" onclick="init()">Add Text</button>
					
					<!--textarea id="textinputarea" rows="5"></textarea-->
				</div>
				<div id="plot_data_form" class="input_controls">
					PLOT CONTROLS<br>
					<button type="button" class="btn btn-block btn-default btn-xs" onclick="init()">Plot Data</button>
					<button type="button" class="btn btn-block btn-default btn-xs" onclick="location.reload();">Reset</button>
					<button type="button" class="btn btn-block btn-default btn-xs" onclick="location.reload();">Export PNG</button><br>
					<button type="button" class="btn btn-block btn-default btn-xs btn-info">Clear Settings</button>
					<!--textarea id="textinputarea" rows="5"></textarea-->
				</div>
			</div>
			<div id="datasheet_container"><div id="datasheet" class="handsontable"></div></div>
		</div>
		<div id="gui_sidebar">
		<div id="about"><u><b>3JScatter</b></u> is a highly customizable 3D-plotter written with three.js. <a href="http://traversching.wordpress.com">traversching.wordpress.com</a></div>
		<div id="savebar">
		<div class="btn-group btn-group-xs" role="group"><button type="button" class="btn btn-default">Save Settings</button>
		<button type="button" class="btn btn-default">Revert</button></div>
		
		<!--span class='savebar-button' id="save_settings">Save Settings</span><span class='savebar-button' id="revert_settings">Revert</span--></div>
		</div>
		
		
		
		
		
		
		
		<script>
		
			initControlGui();
			initDatasheet();
			//var camera, controls, scene, renderer;
			points = [];
			histLines = [];
			//var cube_outlines = [];
			texts = [];
			controls_enabled = false;
			function demo1() {
				gui_vars.cam_init_pos_x = 75;
				gui_vars.cam_init_pos_y = 120;
				gui_vars.cam_init_pos_z = 150;
				$('#textinputarea').get(0).value = demostring01;
				init();
			}
			function demo2() {
				gui_vars.cam_init_pos_x = 20;
				gui_vars.cam_init_pos_y = -10;
				gui_vars.cam_init_pos_z = -150;
				$('#textinputarea').get(0).value = demostring02;
				init();
			}
			function demo3() {
				$('#textinputarea').get(0).value = demostring03;
				init();
			}

			
			function init() {
				$("#plotarea").empty();
				if ( ! Detector.webgl ) {
					var parameters = {parent: $("#plotarea")[0], id : "error"};
					Detector.addGetWebGLMessage(parameters);
					return;
				}
				renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer: true, alpha: true});
				//renderer = new THREE.WebGLRenderer();
				//renderer = new THREE.SVGRenderer({antialias:true});
				var w,h;
				if(gui_vars.fix_width == 'auto') {
					w = document.getElementById('plotarea').clientWidth;
				} else {
					w = parseInt(gui_vars.fix_width);
				}
				if(gui_vars.fix_height == 'auto') {
					h = document.getElementById('plotarea').clientHeight;
				} else {
					h = parseInt(gui_vars.fix_height);
				}
				renderer.setSize(w, h);
				renderer.setClearColor(parseInt(gui_vars.bgcolor), 1.0);
				if(gui_vars.shadows_enabled) {renderer.shadowMapEnabled = true;}
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
				renderer.domElement.id = "myrenderer";
				var plotarea = document.getElementById('plotarea');
				plotarea.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, w / h, 1, 1000);
				renderer.render(scene,camera);
				
				
				//point: x,y,z,pch,color,size,outline_color,hist,hist_color,euler_x,euler_y,euler_z
				//line: x,y,z,lty,line_size,line_color,pch,color,size,outline_color,hist,hist_color,euler_x,euler_y,euler_z
				//text: x,y,z,text,color,size
				//point rotations not yet implemented
				
				var input = document.getElementById('textinputarea').value;
				var input_array = input.split("\n");
				var sre = /^series/;
				var series_inds = input_array.reduce(function(a, e, i) {
					if (e.search(sre) > -1)
						a.push(i);
					return a;
				}, []);
				series_inds.push(input_array.length);
				series_array = [];
				var all_xcoords = [];
				var all_ycoords = [];
				var all_zcoords = [];
				series_inds.reduce(function(start, end) {
					var series = d3.csv.parse(input_array.slice(start,end).join("\n"));
					for(var i=0; i<series.length;i++) {
						all_xcoords.push(series[i].x);
						all_ycoords.push(series[i].y);
						all_zcoords.push(series[i].z);
					}
					series_array.push(series);
					return end;
				})
				var xlim = [Math.min.apply(null,all_xcoords),Math.max.apply(null,all_xcoords)];
				var ylim = [Math.min.apply(null,all_ycoords),Math.max.apply(null,all_ycoords)];
				var zlim = [Math.min.apply(null,all_zcoords),Math.max.apply(null,all_zcoords)];
				
				for(var i=0; i<series_array.length;i++) {
					var series = series_array[i];
					var point_radii = []; for (var i = 0; i < series.length; i++) point_radii[i] = 0; //initialize point radius array
					//add points to scene
					for(var i=0; i<series.length;i++) {
						var size = typeof series[i].size == "undefined" ? default_size : series[i].size;
						var pch = typeof series[i].pch == "undefined" ? default_pch : series[i].pch;
						var color = typeof series[i].color == "undefined" ? default_color : series[i].color;
						var outline_color = typeof series[i].outline_color == "undefined" ? default_outline_color : series[i].outline_color;
						var point = pointMesh(pch, size, color, outline_color);
						
						//compute bounding boxes
						if(point instanceof THREE.Mesh) {
							var geom = point.geometry;
							geom.computeBoundingSphere();
							point_radii[i] = geom.boundingSphere.radius;
						} else { //instanceof THREE.Object3D
							for (var j = 0; j < point.children.length; j ++) {
								point.children[j].geometry.computeBoundingSphere();
								if(point.children[j].geometry.boundingSphere.radius > point_radii[i]) {
									point_radii[i] = point.children[j].geometry.boundingSphere.radius;
								}
							}
						}
						//point_radii[i] = point_radii[i] * 1.05;
						
						var euler_x = typeof series[i].euler_x == "undefined" || series[i].euler_x == "" ? 0 : series[i].euler_x * Math.PI/180;
						var euler_y = typeof series[i].euler_y == "undefined" || series[i].euler_y == "" ? 0 : series[i].euler_y * Math.PI/180;
						var euler_z = typeof series[i].euler_z == "undefined" || series[i].euler_z == "" ? 0 : series[i].euler_z * Math.PI/180;
						point.applyMatrix(new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(euler_x,euler_y,euler_z)));
						
						point.position.x = rescalePosition(series[i].x,xlim[0],xlim[1],gui_vars.scale_x);
						point.position.y = rescalePosition(series[i].y,ylim[0],ylim[1],gui_vars.scale_y);
						point.position.z = rescalePosition(series[i].z,zlim[0],zlim[1],gui_vars.scale_z);
						//console.log(point.rotation);
						//todo: check if shadows enabled
						point.castShadow = true;
						scene.add(point);
					}
					//add line segments to scene
					var prev_coords;
					for(var i=0; i<series.length;i++) {
						var lty = typeof series[i].lty == "undefined" ? default_lty : series[i].lty;
						x = rescalePosition(series[i].x,xlim[0],xlim[1],gui_vars.scale_x);
						y = rescalePosition(series[i].y,ylim[0],ylim[1],gui_vars.scale_y);
						z = rescalePosition(series[i].z,zlim[0],zlim[1],gui_vars.scale_z);
						if(typeof prev_coords == "undefined" || lty == "0" || lty == "") {
							prev_coords = [x,y,z];
							continue;
						}
						var line_size = typeof series[i].line_size == "undefined" ? default_line_size : series[i].line_size;
						var line_color = typeof series[i].line_color == "undefined" ? default_line_color : series[i].line_color;
						var p1 = v(x,y,z);
						var p2 = v(prev_coords[0],prev_coords[1],prev_coords[2]);
						var seg_len = p1.sub(p2).length();
						var r1 = lty == "1" ? point_radii[i-1] : point_radii[i-1] * 1.05;
						var r2 = lty == "1" ? point_radii[i] : point_radii[i] * 1.05;
						if(seg_len < r1 + r2) {
							prev_coords = [x,y,z];
							continue;
						}
						var line_segment = lineSegmentMesh(prev_coords, [x,y,z], line_size, line_color, lty, r1, r2, true);
						prev_coords = [x,y,z];
						scene.add(line_segment);
					}
				}
				
				/*
				//add hist to scene
				//could make hist line a tube instead, for more customizability
				for (var i = 0; i < unfiltered.length; i ++) {
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var hist = hist_ind == -1 ? default_hist : unfiltered[i][hist_ind];
					var hist_color = hist_color_ind == -1 ? default_hist_color : unfiltered[i][hist_color_ind];
					if(hist == 1) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, 0), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
					if(hist == 2) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, -gui_vars.scale_z * 1.25), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
				}*/
				
				//coordinate axes: to do: clean up and make more organized
				if(gui_vars.axes_origin != 'auto') {
					var axes_origin = gui_vars.axes_origin.split(",");
					ao_rescaled_x = rescalePosition(parseFloat(axes_origin[0]),xlim[0],xlim[1],gui_vars.scale_x);
					ao_rescaled_y = rescalePosition(parseFloat(axes_origin[1]),ylim[0],ylim[1],gui_vars.scale_y);
					ao_rescaled_z = rescalePosition(parseFloat(axes_origin[2]),zlim[0],zlim[1],gui_vars.scale_z);
				} else {
					ao_rescaled_x = 0;
					ao_rescaled_y = 0;
					ao_rescaled_z = 0;
				}
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z), v(-gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(ao_rescaled_x, gui_vars.scale_y * 1.25, ao_rescaled_z), v(ao_rescaled_x, -gui_vars.scale_y * 1.25, ao_rescaled_z));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.25), v(ao_rescaled_x, ao_rescaled_y, -gui_vars.scale_z * 1.25));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				
				//arrows
				var triangle = new THREE.Shape();
				triangle.moveTo(0,0);
				triangle.lineTo(2, -4);
				triangle.lineTo(-2, -4);
				triangle.lineTo(0,0);
				var geometry = triangle.makeGeometry();
				var material = new THREE.MeshBasicMaterial({ color: 0x000000 });
				material.side = THREE.DoubleSide;
				zarrow = new THREE.Mesh(geometry, material);
				zarrow.position.set(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.25);
				zarrow.rotation.x = Math.PI/2;
				scene.add( zarrow );
				xarrow = new THREE.Mesh(geometry, material);
				xarrow.position.set(gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z);
				xarrow.rotation.z = -Math.PI/2;
				scene.add( xarrow );
				yarrow = new THREE.Mesh(geometry, material);
				yarrow.position.set(ao_rescaled_x, gui_vars.scale_x * 1.25, ao_rescaled_z);
				scene.add( yarrow );
				
				// bottom plane for shadows / reflections
				var geometry = new THREE.PlaneGeometry(10000,10000);
				var plane_mat = new THREE.MeshBasicMaterial( {color: parseInt(gui_vars.bgcolor)} );
				var plane = new THREE.Mesh( geometry, plane_mat );
				plane.receiveShadow = true;
				plane.position.z = -gui_vars.scale_z * 1.25;
				scene.add( plane );

				//text
				//text3d.computeBoundingBox();
				//var centerOffsetx = -0.5 * (text3d.boundingBox.max.x - text3d.boundingBox.min.x);
				//var centerOffsetz = -0.5 * ( text3d.boundingBox.max.z - text3d.boundingBox.min.z );
				var textMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_x, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				text3d.center();
				var x_lab = new THREE.Mesh(text3d, textMaterial);
				x_lab.position.set(gui_vars.scale_x * 1.30 + text3d.boundingBox.max.x, ao_rescaled_y, ao_rescaled_z);
				texts.push(x_lab);
				scene.add( x_lab );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_y, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				var y_lab = new THREE.Mesh( text3d, textMaterial );
				text3d.center();
				y_lab.position.set(ao_rescaled_x, gui_vars.scale_x * 1.30 + text3d.boundingBox.max.x, ao_rescaled_z);
				texts.push(y_lab);
				scene.add( y_lab );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_z, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				var z_lab = new THREE.Mesh( text3d, textMaterial );
				text3d.center();
				z_lab.position.set(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.45);
				texts.push(z_lab);
				scene.add( z_lab );
					
				// lights
				if(gui_vars.light_enabled) {
					light = new THREE.SpotLight( 0xcccccc );
					light.position.set( 0,0, 1000);
					light.castShadow = true;
					light.shadowDarkness = 0.5;
					light.shadowCameravisible = true;
					scene.add( light );
				}
				
				camera.position.z = gui_vars.cam_pos_x;
				camera.position.x = gui_vars.cam_pos_y;
				camera.position.y = gui_vars.cam_pos_z;
				camera.up = v(0,0,1);
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.damping = 0.2;
				
				controls_enabled = true;
				animate();
			}
			function animate() {
				if(controls_enabled) {
					requestAnimationFrame(animate);
					//for(var k = 0; k<cube_outlines.length; k++){
					//	cube_outlines[k].lookAt( camera.position );  					 
					//}
					for(var k = 0; k<texts.length; k++){
						texts[k].quaternion.copy( camera.quaternion );					
					}
					//console.log(zaxis.rotation);
					//mesh.lookAt(camera.position);	
					zarrow.rotation.x = Math.PI/2;
					zarrow.rotation.z = 0;
					zarrow.rotation.y = -Math.atan(camera.position.x/camera.position.y);
					//console.log(mesh.rotation.y);
					//mesh.rotation.y +=0.1;
					renderer.render(scene, camera);
					controls.update();
				}
			}	
		</script>
	</body>
</html>
