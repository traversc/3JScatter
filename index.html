<html>
<head>
<title>3JScatter: 3D scatter plotter</title>
	<script src="js/three.min_v69.js"></script>  
	<script src="js/OrbitControls.js"></script>
	<script src="js/d3.v3.min.js"></script>
	<script src="js/helvetiker_regular.typeface.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/jquery-1.11.2.min.js"></script>
	<script src="js/customDataAndFunctions.js"></script>
	<link type="text/css" href="css/styles.css" rel="stylesheet"/>
	<!--script src="js/SVGRenderer.js"></script-->

</head>
	<body>
		<div id="title">3JScatter: 3D scatter plotter</div>
		<div id="plotarea"><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 1: <a href="javascript:demo1();">Tissue sub-type Principal Component Analysis</a><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 2: <a href="javascript:demo2();">Different shape example</a><br><br>
		</div>
		<div id ="footer">
		<form id="form1">
			Input Data<br><input type="button" value="Plot Data" onclick="init()"><input type="button" value="Reset" onclick="location.reload();">
			<textarea id="textinputarea" rows="5"></textarea>
		</form>
		</div>
		<script>
			var camera, controls, scene, renderer;
			var points = [];
			var histLines = [];
			//var cube_outlines = [];
			var texts = [];
			var controls_enabled = false;
			function demo1() {
				cam_init_pos = [75,120,150];
				$('#textinputarea').get(0).value = demostring01;
				$("#plotarea").empty();
				init();
			}
			function demo2() {
				cam_init_pos = [20,-10,-150];
				$('#textinputarea').get(0).value = demostring02;
				$("#plotarea").empty();
				init();
			}
			
			//dat.gui variables
			function exportpng() {
				window.open(renderer.domElement.toDataURL('image/png'),'screenshot');
			}	
			function freeze() {
				controls_enabled = !controls_enabled;
				if(controls_enabled && typeof renderer != 'undefined') {
					animate();
				}
			}
			function clearSettings() {
				localStorage.clear();
				location.reload();
			}
			var light_enabled = true;
			var shadows_enabled = false;
			var fix_plot_dimensions = false;
			var fix_axes_loc = false;
			var axes_origin_x = '0';
			var axes_origin_y = '0';
			var axes_origin_z = '0';
			var gui = new dat.GUI({width:300});
			gui.remember(this);
			localStorage.setItem(document.location.href + '.isLocal','true'); //default save to local storage automatically
			var light_control = gui.add(this, 'light_enabled').name('Add Light');
			var shadow_control = gui.add(this, 'shadows_enabled').name('Enable Shadows');
			
			//axes location
			var axes_origin_folder = gui.addFolder('Fix Axes Origin');
			var fix_axes_control = axes_origin_folder.add(this, 'fix_axes_loc').name('Set Origin of Axes');
			axes_origin_folder.add(this, 'axes_origin_x').name('X');
			axes_origin_folder.add(this, 'axes_origin_y').name('Y');
			axes_origin_folder.add(this, 'axes_origin_z').name('Z');
			axes_origin_folder.open();
			
			//plot size controls //plotsize_folder.open();
			var plotsize_folder = gui.addFolder('Fix Plot Dimensions');
			var fix_size_control = plotsize_folder.add(this, 'fix_plot_dimensions').name('Fix Plot Size');
			plotsize_folder.add(this, 'fix_height', 480,1440).name('Plot Height');
			plotsize_folder.add(this, 'fix_width', 640,2560).name('Plot Width');
			plotsize_folder.open();

			function reset() { //reload webpage, is there a better way?
				location.reload();
			}
			//gui.add(this, 'freeze').name('Freeze/Unfreeze');
			gui.add(this, 'exportpng').name('Export as PNG');
			gui.add(this, 'reset').name('Reset Plot');
			gui.add(this, 'clearSettings').name('Clear Settings');
			gui.close();			
			function init() {
				renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer: true, alpha: true});
				//renderer = new THREE.WebGLRenderer();
				//renderer = new THREE.SVGRenderer({antialias:true});
				var w,h;
				if(fix_plot_dimensions) {
					w = fix_width;
					h = fix_height;
				} else {
					w = document.getElementById('plotarea').clientWidth;
					h = document.getElementById('plotarea').clientHeight;
				}
				renderer.setSize(w, h);
				renderer.setClearColor(bgcolor, 1.0);
				if(shadows_enabled) {
					console.log("shadows");
					renderer.shadowMapEnabled = true;
				}
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
				renderer.domElement.id = "myrenderer";
				var plotarea = document.getElementById('plotarea');
				plotarea.appendChild(renderer.domElement);
				//controls.addEventListener( 'change', render );
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, w / h, 1, 1000);
				renderer.render(scene,camera);
				var text = document.getElementById('textinputarea').value; 
				var unfiltered = d3.csv.parseRows(text);			
				var labels = unfiltered[0];
				unfiltered.shift(); //remove first element (header)		
				var x_ind = labels.indexOf("x");
				var y_ind = labels.indexOf("y");
				var z_ind = labels.indexOf("z");
				var size_ind = labels.indexOf("size");
				var hist_ind = labels.indexOf("hist");
				var pch_ind = labels.indexOf("pch");
				var color_ind = labels.indexOf("color");
				var hist_color_ind = labels.indexOf("hist_color");
				var outline_color_ind = labels.indexOf("outline_color");
				var lty_ind = labels.indexOf("lty");
				var line_size_ind = labels.indexOf("line_size");
				var line_color_ind = labels.indexOf("line_color");
				
				var xcoords = unfiltered.map(function(v) {return rescalePosition(v[x_ind],colMin(unfiltered,x_ind),colMax(unfiltered,x_ind),xscale)});
				var ycoords = unfiltered.map(function(v) {return rescalePosition(v[y_ind],colMin(unfiltered,y_ind),colMax(unfiltered,y_ind),yscale)});
				var zcoords = unfiltered.map(function(v) {return rescalePosition(v[z_ind],colMin(unfiltered,z_ind),colMax(unfiltered,z_ind),zscale)});
				
				//add points to scene
				var point_radii = []; for (var i = 0; i < unfiltered.length; i++) point_radii[i] = 0; //initialize point radius array
				for (var i = 0; i < unfiltered.length; i ++) {
					var size = size_ind == -1 ? default_size : unfiltered[i][size_ind];
					var pch = size_ind == -1 ? default_pch : unfiltered[i][pch_ind];
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var color = color_ind == -1 ? default_color : unfiltered[i][color_ind];
					var outline_color = outline_color_ind == -1 ? default_outline_color : unfiltered[i][outline_color_ind];
					var point = pointMesh(pch, size, color, outline_color);
					
					//compute bounding boxes
					if(point instanceof THREE.Mesh) {
						var geom = point.geometry;
						geom.computeBoundingSphere();
						point_radii[i] = geom.boundingSphere.radius;
					} else { //instanceof THREE.Object3D
						for (var j = 0; j < point.children.length; j ++) {
							point.children[j].geometry.computeBoundingSphere();
							if(point.children[j].geometry.boundingSphere.radius > point_radii[i]) {
								point_radii[i] = point.children[j].geometry.boundingSphere.radius;
							}
						}
					}
					point_radii[i] = point_radii[i] * 1.05;
					
					point.position.x = x;
					point.position.y = y;
					point.position.z = z;
					point.castShadow = true;
					scene.add(point);
				}
				
				//add line segments to scene
				if(lty_ind != -1) {
					var prev_coords = undefined;
					for (var i = 0; i < unfiltered.length; i ++) {
						var x = xcoords[i];
						var y = ycoords[i];
						var z = zcoords[i];
						if(typeof prev_coords == "undefined" || lty == "0") {
							prev_coords = [x,y,z];
							continue;
						}
						var lty = unfiltered[i][lty_ind] != "" ? unfiltered[i][lty_ind] : default_lty;
						var line_size = line_size_ind == -1 ? default_line_size : unfiltered[i][line_size_ind];
						line_size = line_size != "" ? line_size : default_line_size;
						var line_color = line_color_ind == -1 ? default_line_color : unfiltered[i][line_color_ind];
						line_color = line_color != "" ? line_color : default_line_color;
						if(lty == "2") {
							p1 = v(x,y,z);
							p2 = v(prev_coords[0],prev_coords[1],prev_coords[2]);
							var seg_len = p1.sub(p2).length();
							var r1 = point_radii[i-1];
							var r2 = point_radii[i];
							if(seg_len < r1 + r2) {
								prev_coords = [x,y,z];
								continue;
							}
							var line_segment = lineSegmentMesh(prev_coords, [x,y,z], line_size, line_color, lty, r1, r2, true);
						} else {
							var line_segment = lineSegmentMesh(prev_coords, [x,y,z], line_size, line_color, lty, 0, 0, true);
						}
						prev_coords = [x,y,z];
						scene.add(line_segment);
					}
				}
				
				//add hist to scene
				//could make hist line a tube instead, for more customizability
				for (var i = 0; i < unfiltered.length; i ++) {
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var hist = hist_ind == -1 ? default_hist : unfiltered[i][hist_ind];
					var hist_color = hist_color_ind == -1 ? default_hist_color : unfiltered[i][hist_color_ind];
					if(hist == 1) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, 0), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
					if(hist == 2) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, -zscale * 1.25), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
				}
				
				//coordinate axes: to do: clean up and make more organized
				if(fix_axes_loc) {
					ao_rescaled_x = rescalePosition(parseFloat(axes_origin_x),colMin(unfiltered,x_ind),colMax(unfiltered,x_ind),xscale);
					ao_rescaled_y = rescalePosition(parseFloat(axes_origin_y),colMin(unfiltered,y_ind),colMax(unfiltered,y_ind),yscale);
					ao_rescaled_z = rescalePosition(parseFloat(axes_origin_z),colMin(unfiltered,z_ind),colMax(unfiltered,z_ind),zscale);
				} else {
					ao_rescaled_x = 0;
					ao_rescaled_y = 0;
					ao_rescaled_z = 0;
				}
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(
					v(xscale * 1.25, ao_rescaled_y, ao_rescaled_z), v(-xscale * 1.25, ao_rescaled_y, ao_rescaled_z),
					v(ao_rescaled_x, yscale * 1.25, ao_rescaled_z), v(ao_rescaled_x, -yscale * 1.25, ao_rescaled_z),
					v(ao_rescaled_x, ao_rescaled_y, zscale * 1.25), v(ao_rescaled_x, ao_rescaled_y, -zscale * 1.25));
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				
				//arrows
				var triangle = new THREE.Shape();
				triangle.moveTo(0,0);
				triangle.lineTo(0.5, -1);
				triangle.lineTo(-0.5, -1);
				triangle.lineTo(0,0);
				var geometry = triangle.makeGeometry();
				var material = new THREE.MeshBasicMaterial({ color: 0x000000 });
				material.side = THREE.DoubleSide;
				zarrow = new THREE.Mesh(geometry, material);
				zarrow.position.set(ao_rescaled_x, ao_rescaled_y, zscale * 1.25);
				zarrow.rotation.x = Math.PI/2;
				scene.add( zarrow );
				xarrow = new THREE.Mesh(geometry, material);
				xarrow.position.set(xscale * 1.25, ao_rescaled_y, ao_rescaled_z);
				xarrow.rotation.z = -Math.PI/2;
				scene.add( xarrow );
				yarrow = new THREE.Mesh(geometry, material);
				yarrow.position.set(ao_rescaled_x, xscale * 1.25 + 1, ao_rescaled_z);
				scene.add( yarrow );
				
				// bottom plane for shadows / reflections
				var geometry = new THREE.PlaneGeometry(10000,10000);
				var plane_mat = new THREE.MeshBasicMaterial( {color: bgcolor} );
				var plane = new THREE.Mesh( geometry, plane_mat );
				plane.receiveShadow = true;
				plane.position.z = -zscale * 1.25;
				scene.add( plane );

				//text
				//text3d.computeBoundingBox();
				//var centerOffsetx = -0.5 * ( text3d.boundingBox.max.x - text3d.boundingBox.min.x );
				//var centerOffsetz = -0.5 * ( text3d.boundingBox.max.z - text3d.boundingBox.min.z );
				var textMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } );
				var text3d = new THREE.TextGeometry( "x", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				THREE.GeometryUtils.center( text3d )
				var x_lab = new THREE.Mesh( text3d, textMaterial );
				x_lab.position.set(xscale * 1.35, ao_rescaled_y, ao_rescaled_z);
				texts.push(x_lab);
				scene.add( x_lab );
				var text3d = new THREE.TextGeometry( "y", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				var y_lab = new THREE.Mesh( text3d, textMaterial );
				THREE.GeometryUtils.center( text3d )
				y_lab.position.set(ao_rescaled_x, xscale * 1.35, ao_rescaled_z);
				texts.push(y_lab);
				scene.add( y_lab );
				var text3d = new THREE.TextGeometry( "z", {size: 2,height: 0,curveSegments: 2,font: "helvetiker"});
				var z_lab = new THREE.Mesh( text3d, textMaterial );
				THREE.GeometryUtils.center( text3d )
				z_lab.position.set(ao_rescaled_x, ao_rescaled_y, zscale * 1.45);
				texts.push(z_lab);
				scene.add( z_lab );
					
				// lights
				if(light_enabled) {
					light = new THREE.SpotLight( 0xcccccc );
					light.position.set( 0,0, 1000);
					light.castShadow = true;
					light.shadowDarkness = 0.5;
					light.shadowCameravisible = true;
					scene.add( light );
				}
				
				camera.position.z = cam_init_pos[0];
				camera.position.x = cam_init_pos[1];
				camera.position.y = cam_init_pos[2];
				camera.up = v( 0, 0, 1 );
				controls = new THREE.OrbitControls( camera );
				controls.damping = 0.2;
				
				controls_enabled = true;
				animate();
			}
			function animate() {
				if(controls_enabled) {
					requestAnimationFrame(animate);
					//for(var k = 0; k<cube_outlines.length; k++){
					//	cube_outlines[k].lookAt( camera.position );  					 
					//}
					for(var k = 0; k<texts.length; k++){
						texts[k].quaternion.copy( camera.quaternion );					
					}
					//console.log(zaxis.rotation);
					//mesh.lookAt(camera.position);	
					zarrow.rotation.x = Math.PI/2;
					zarrow.rotation.z = 0;
					zarrow.rotation.y = -Math.atan(camera.position.x/camera.position.y);
					//console.log(mesh.rotation.y);
					//mesh.rotation.y +=0.1;
					renderer.render(scene, camera);
					controls.update();
				}
			}	
		</script>
	</body>
</html>
