<html>
<head>
<title>3JScatter: 3D scatter plotter</title>
	<!--predefined libraries-->
	<script src="js/three.min.v69.js"></script>  
	<script src="js/OrbitControls.js"></script>
	<script src="js/d3.v3.min.js"></script>
	<script src="js/helvetiker_regular.typeface.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/jquery-1.11.2.min.js"></script>
	
	<!--own code-->
	<script src="js/_my.functions.js"></script>
	<script src="js/_my.gui.controls.js"></script>
	<link type="text/css" href="css/styles.css" rel="stylesheet"/>

</head>
	<body>
		<!--div id="title">3JScatter: 3D scatter plotter</div-->
		<div id="plotarea"><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 1: <a href="javascript:demo1();">Tissue sub-type Principal Component Analysis</a><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 2: <a href="javascript:demo2();">Different shape example</a><br>
		&nbsp;&nbsp;&nbsp;&nbsp;Demo 3: <a href="javascript:demo3();">Line plot example (Dow Jones Industrial Average)</a><br><br>
		</div>
		<div id="footer">
		<form id="form1">
			Input Data<br><input type="button" value="Plot Data" onclick="init()"><input type="button" value="Reset" onclick="location.reload();">
			<textarea id="textinputarea" rows="5"></textarea>
		</form>
		</div>
		<div id="guiContainer">
		<div id="about"><u><b>3JScatter</b></u> is a highly customizable 3D-plotter written with three.js. <a href="http://traversching.wordpress.com">traversching.wordpress.com</a></div>
		<div id="savebar"><span class='savebar-button' id="save_settings">Save Settings</span><span class='savebar-button' id="revert_settings">Revert</span></div>
		
		
		</div>
		
		
		
		
		
		
		
		<script>
			//var camera, controls, scene, renderer;
			var points = [];
			var histLines = [];
			//var cube_outlines = [];
			var texts = [];
			var controls_enabled = false;
			function demo1() {
				gui_vars.cam_init_pos_x = 75;
				gui_vars.cam_init_pos_y = 120;
				gui_vars.cam_init_pos_z = 150;
				$('#textinputarea').get(0).value = demostring01;
				init();
			}
			function demo2() {
				gui_vars.cam_init_pos_x = 20;
				gui_vars.cam_init_pos_y = -10;
				gui_vars.cam_init_pos_z = -150;
				$('#textinputarea').get(0).value = demostring02;
				init();
			}
			function demo3() {
				$('#textinputarea').get(0).value = demostring03;
				init();
			}

			initControlGui();
			
			function init() {
				$("#plotarea").empty();
				renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer: true, alpha: true});
				//renderer = new THREE.WebGLRenderer();
				//renderer = new THREE.SVGRenderer({antialias:true});
				var w,h;
				if(gui_vars.fix_width == 'auto') {
					w = document.getElementById('plotarea').clientWidth;
				} else {
					w = parseInt(gui_vars.fix_width);
				}
				if(gui_vars.fix_height == 'auto') {
					h = document.getElementById('plotarea').clientHeight;
				} else {
					h = parseInt(gui_vars.fix_height);
				}
				renderer.setSize(w, h);
				renderer.setClearColor(parseInt(gui_vars.bgcolor), 1.0);
				if(gui_vars.shadows_enabled) {renderer.shadowMapEnabled = true;}
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
				renderer.domElement.id = "myrenderer";
				var plotarea = document.getElementById('plotarea');
				plotarea.appendChild(renderer.domElement);
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, w / h, 1, 1000);
				renderer.render(scene,camera);
				var text = document.getElementById('textinputarea').value; 
				var unfiltered = d3.csv.parseRows(text);			
				var labels = unfiltered[0];
				unfiltered.shift(); //remove first element (header)		
				var x_ind = labels.indexOf("x");
				var y_ind = labels.indexOf("y");
				var z_ind = labels.indexOf("z");
				var size_ind = labels.indexOf("size");
				var hist_ind = labels.indexOf("hist");
				var pch_ind = labels.indexOf("pch");
				var color_ind = labels.indexOf("color");
				var hist_color_ind = labels.indexOf("hist_color");
				var outline_color_ind = labels.indexOf("outline_color");
				var lty_ind = labels.indexOf("lty");
				var line_size_ind = labels.indexOf("line_size");
				var line_color_ind = labels.indexOf("line_color");
				
				var xcoords = unfiltered.map(function(v) {return rescalePosition(v[x_ind],colMin(unfiltered,x_ind),colMax(unfiltered,x_ind),gui_vars.scale_x)});
				var ycoords = unfiltered.map(function(v) {return rescalePosition(v[y_ind],colMin(unfiltered,y_ind),colMax(unfiltered,y_ind),gui_vars.scale_y)});
				var zcoords = unfiltered.map(function(v) {return rescalePosition(v[z_ind],colMin(unfiltered,z_ind),colMax(unfiltered,z_ind),gui_vars.scale_z)});
				
				//add points to scene
				var point_radii = []; for (var i = 0; i < unfiltered.length; i++) point_radii[i] = 0; //initialize point radius array
				for (var i = 0; i < unfiltered.length; i ++) {
					var size = size_ind == -1 ? default_size : unfiltered[i][size_ind];
					var pch = size_ind == -1 ? default_pch : unfiltered[i][pch_ind];
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var color = color_ind == -1 ? default_color : unfiltered[i][color_ind];
					var outline_color = outline_color_ind == -1 ? default_outline_color : unfiltered[i][outline_color_ind];
					var point = pointMesh(pch, size, color, outline_color);
					
					//compute bounding boxes
					if(point instanceof THREE.Mesh) {
						var geom = point.geometry;
						geom.computeBoundingSphere();
						point_radii[i] = geom.boundingSphere.radius;
					} else { //instanceof THREE.Object3D
						for (var j = 0; j < point.children.length; j ++) {
							point.children[j].geometry.computeBoundingSphere();
							if(point.children[j].geometry.boundingSphere.radius > point_radii[i]) {
								point_radii[i] = point.children[j].geometry.boundingSphere.radius;
							}
						}
					}
					point_radii[i] = point_radii[i] * 1.05;
					
					point.position.x = x;
					point.position.y = y;
					point.position.z = z;
					point.castShadow = true;
					scene.add(point);
				}
				
				//add line segments to scene
				if(lty_ind != -1) {
					var prev_coords = undefined;
					for (var i = 0; i < unfiltered.length; i ++) {
						var x = xcoords[i];
						var y = ycoords[i];
						var z = zcoords[i];
						if(typeof prev_coords == "undefined" || lty == "0") {
							prev_coords = [x,y,z];
							continue;
						}
						var lty = unfiltered[i][lty_ind] != "" ? unfiltered[i][lty_ind] : default_lty;
						var line_size = line_size_ind == -1 ? default_line_size : unfiltered[i][line_size_ind];
						line_size = line_size != "" ? line_size : default_line_size;
						var line_color = line_color_ind == -1 ? default_line_color : unfiltered[i][line_color_ind];
						line_color = line_color != "" ? line_color : default_line_color;
						if(lty == "2") {
							p1 = v(x,y,z);
							p2 = v(prev_coords[0],prev_coords[1],prev_coords[2]);
							var seg_len = p1.sub(p2).length();
							var r1 = point_radii[i-1];
							var r2 = point_radii[i];
							if(seg_len < r1 + r2) {
								prev_coords = [x,y,z];
								continue;
							}
							var line_segment = lineSegmentMesh(prev_coords, [x,y,z], line_size, line_color, lty, r1, r2, true);
						} else {
							var line_segment = lineSegmentMesh(prev_coords, [x,y,z], line_size, line_color, lty, 0, 0, true);
						}
						prev_coords = [x,y,z];
						scene.add(line_segment);
					}
				}
				
				//add hist to scene
				//could make hist line a tube instead, for more customizability
				for (var i = 0; i < unfiltered.length; i ++) {
					var x = xcoords[i];
					var y = ycoords[i];
					var z = zcoords[i];
					var hist = hist_ind == -1 ? default_hist : unfiltered[i][hist_ind];
					var hist_color = hist_color_ind == -1 ? default_hist_color : unfiltered[i][hist_color_ind];
					if(hist == 1) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, 0), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
					if(hist == 2) {
						var lineGeo = new THREE.Geometry();
						lineGeo.vertices.push(
							v(x, y, -gui_vars.scale_z * 1.25), v(x, y, z)
						);
						var lineMat = new THREE.LineBasicMaterial({color: hist_color,lineWidth: 1, transparent: true, opacity: 0.11});
						var line = new THREE.Line(lineGeo, lineMat);
						line.type = THREE.Lines;
						histLines.push(line);
						scene.add(line);
					}
				}
				
				//coordinate axes: to do: clean up and make more organized
				if(gui_vars.axes_origin != 'auto') {
					var axes_origin = gui_vars.axes_origin.split(",");
					ao_rescaled_x = rescalePosition(parseFloat(axes_origin[0]),colMin(unfiltered,x_ind),colMax(unfiltered,x_ind),gui_vars.scale_x);
					ao_rescaled_y = rescalePosition(parseFloat(axes_origin[1]),colMin(unfiltered,y_ind),colMax(unfiltered,y_ind),gui_vars.scale_y);
					ao_rescaled_z = rescalePosition(parseFloat(axes_origin[2]),colMin(unfiltered,z_ind),colMax(unfiltered,z_ind),gui_vars.scale_z);
				} else {
					ao_rescaled_x = 0;
					ao_rescaled_y = 0;
					ao_rescaled_z = 0;
				}
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z), v(-gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(ao_rescaled_x, gui_vars.scale_y * 1.25, ao_rescaled_z), v(ao_rescaled_x, -gui_vars.scale_y * 1.25, ao_rescaled_z));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				var lineMat = new THREE.LineBasicMaterial({color: 0x000000,lineWidth: 1});
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(v(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.25), v(ao_rescaled_x, ao_rescaled_y, -gui_vars.scale_z * 1.25));
				var line = new THREE.Line(lineGeo, lineMat);
				line.type = THREE.Lines;
				scene.add(line);
				
				//arrows
				var triangle = new THREE.Shape();
				triangle.moveTo(0,0);
				triangle.lineTo(2, -4);
				triangle.lineTo(-2, -4);
				triangle.lineTo(0,0);
				var geometry = triangle.makeGeometry();
				var material = new THREE.MeshBasicMaterial({ color: 0x000000 });
				material.side = THREE.DoubleSide;
				zarrow = new THREE.Mesh(geometry, material);
				zarrow.position.set(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.25);
				zarrow.rotation.x = Math.PI/2;
				scene.add( zarrow );
				xarrow = new THREE.Mesh(geometry, material);
				xarrow.position.set(gui_vars.scale_x * 1.25, ao_rescaled_y, ao_rescaled_z);
				xarrow.rotation.z = -Math.PI/2;
				scene.add( xarrow );
				yarrow = new THREE.Mesh(geometry, material);
				yarrow.position.set(ao_rescaled_x, gui_vars.scale_x * 1.25, ao_rescaled_z);
				scene.add( yarrow );
				
				// bottom plane for shadows / reflections
				var geometry = new THREE.PlaneGeometry(10000,10000);
				var plane_mat = new THREE.MeshBasicMaterial( {color: parseInt(gui_vars.bgcolor)} );
				var plane = new THREE.Mesh( geometry, plane_mat );
				plane.receiveShadow = true;
				plane.position.z = -gui_vars.scale_z * 1.25;
				scene.add( plane );

				//text
				//text3d.computeBoundingBox();
				//var centerOffsetx = -0.5 * (text3d.boundingBox.max.x - text3d.boundingBox.min.x);
				//var centerOffsetz = -0.5 * ( text3d.boundingBox.max.z - text3d.boundingBox.min.z );
				var textMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_x, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				text3d.center();
				var x_lab = new THREE.Mesh(text3d, textMaterial);
				x_lab.position.set(gui_vars.scale_x * 1.30 + text3d.boundingBox.max.x, ao_rescaled_y, ao_rescaled_z);
				texts.push(x_lab);
				scene.add( x_lab );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_y, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				var y_lab = new THREE.Mesh( text3d, textMaterial );
				text3d.center();
				y_lab.position.set(ao_rescaled_x, gui_vars.scale_x * 1.30 + text3d.boundingBox.max.x, ao_rescaled_z);
				texts.push(y_lab);
				scene.add( y_lab );
				text3d = new THREE.TextGeometry( gui_vars.axes_label_z, {size: 8,height: 0,curveSegments: 2,font: "helvetiker"});
				var z_lab = new THREE.Mesh( text3d, textMaterial );
				text3d.center();
				z_lab.position.set(ao_rescaled_x, ao_rescaled_y, gui_vars.scale_z * 1.45);
				texts.push(z_lab);
				scene.add( z_lab );
					
				// lights
				if(gui_vars.light_enabled) {
					light = new THREE.SpotLight( 0xcccccc );
					light.position.set( 0,0, 1000);
					light.castShadow = true;
					light.shadowDarkness = 0.5;
					light.shadowCameravisible = true;
					scene.add( light );
				}
				
				camera.position.z = gui_vars.cam_pos_x;
				camera.position.x = gui_vars.cam_pos_y;
				camera.position.y = gui_vars.cam_pos_z;
				camera.up = v(0,0,1);
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.damping = 0.2;
				
				controls_enabled = true;
				animate();
			}
			function animate() {
				if(controls_enabled) {
					requestAnimationFrame(animate);
					//for(var k = 0; k<cube_outlines.length; k++){
					//	cube_outlines[k].lookAt( camera.position );  					 
					//}
					for(var k = 0; k<texts.length; k++){
						texts[k].quaternion.copy( camera.quaternion );					
					}
					//console.log(zaxis.rotation);
					//mesh.lookAt(camera.position);	
					zarrow.rotation.x = Math.PI/2;
					zarrow.rotation.z = 0;
					zarrow.rotation.y = -Math.atan(camera.position.x/camera.position.y);
					//console.log(mesh.rotation.y);
					//mesh.rotation.y +=0.1;
					renderer.render(scene, camera);
					controls.update();
				}
			}	
		</script>
	</body>
</html>
